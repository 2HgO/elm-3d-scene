-- Generated by scripts/GenerateShaders.elm, please do not edit by hand


module Scene3d.Shaders exposing
    ( colorTextureFragment
    , constantFragment
    , constantPointFragment
    , emissiveFragment
    , emissivePointFragment
    , emissiveTextureFragment
    , lambertianFragment
    , lambertianTextureFragment
    , normalMappedVertex
    , physicalFragment
    , physicalTexturesFragment
    , plainVertex
    , pointVertex
    , quadShadowVertex
    , quadVertex
    , shadowFragment
    , shadowVertex
    , sphereShadowVertex
    , texturedVertex
    , uniformVertex
    , unlitVertex
    )

import Math.Matrix4 as Matrix4 exposing (Mat4)
import Math.Vector2 as Vector2 exposing (Vec2)
import Math.Vector3 as Vector3 exposing (Vec3)
import Math.Vector4 as Vector4 exposing (Vec4)
import WebGL
import WebGL.Texture exposing (Texture)


plainVertex :
    WebGL.Shader
        { attributes
            | position : Vec3
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
plainVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 position;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main () {
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            gl_Position = project(viewMatrix * worldPosition, sceneProperties[0]);
            interpolatedPosition = worldPosition.xyz;
            interpolatedNormal = vec3(0.0, 0.0, 0.0);
            interpolatedUv = vec2(0.0, 0.0);
            interpolatedTangent = vec3(0.0, 0.0, 0.0);
        }
    |]


unlitVertex :
    WebGL.Shader
        { attributes
            | position : Vec3
            , uv : Vec2
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
unlitVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 position;
        attribute vec2 uv;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main() {
            vec4 worldPosition = getWorldPosition(position, modelSale, modelMatrix);
            gl_Position = project(viewMatrix * worldPosition, sceneProperties[0]);
            interpolatedPosition = worldPosition.xyz;
            interpolatedUv = uv;
            interpolatedNormal = vec3(0.0, 0.0, 0.0);
            interpolatedTangent = vec3(0.0, 0.0, 0.0);
        }
    |]


uniformVertex :
    WebGL.Shader
        { attributes
            | position : Vec3
            , normal : Vec3
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
uniformVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 position;
        attribute vec3 normal;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec3 getWorldDirection(vec3 modelDirection, mat4 modelMatrix) {
            return (modelMatrix * vec4(modelDirection, 0.0)).xyz;
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main () {
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            gl_Position = project(viewMatrix * worldPosition, sceneProperties[0]);
            interpolatedPosition = worldPosition.xyz;
            interpolatedNormal = getWorldDirection(normal, modelMatrix);
            interpolatedUv = vec2(0.0, 0.0);
            interpolatedTangent = vec3(0.0, 0.0, 0.0);
        }
    |]


texturedVertex :
    WebGL.Shader
        { attributes
            | position : Vec3
            , normal : Vec3
            , uv : Vec2
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
texturedVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 position;
        attribute vec3 normal;
        attribute vec2 uv;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec3 getWorldDirection(vec3 modelDirection, mat4 modelMatrix) {
            return (modelMatrix * vec4(modelDirection, 0.0)).xyz;
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main () {
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            gl_Position = project(viewMatrix * worldPosition, sceneProperties[0]);
            interpolatedPosition = worldPosition.xyz;
            interpolatedNormal = getWorldDirection(normal, modelMatrix);
            interpolatedUv = uv;
            interpolatedTangent = vec3(0.0, 0.0, 0.0);
        }
    |]


normalMappedVertex :
    WebGL.Shader
        { attributes
            | position : Vec3
            , normal : Vec3
            , uv : Vec2
            , tangent : Vec3
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
normalMappedVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 position;
        attribute vec3 normal;
        attribute vec2 uv;
        attribute vec3 tangent;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec3 getWorldDirection(vec3 modelDirection, mat4 modelMatrix) {
            return (modelMatrix * vec4(modelDirection, 0.0)).xyz;
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main () {
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            gl_Position = project(viewMatrix * worldPosition, sceneProperties[0]);
            interpolatedPosition = worldPosition.xyz;
            interpolatedNormal = getWorldDirection(normal, modelMatrix);
            interpolatedUv = uv;
            interpolatedTangent = getWorldDirection(tangent, modelMatrix);
        }
    |]


quadVertex :
    WebGL.Shader
        { attributes
            | quadVertex : Vec3
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
            , quadVertexPositions : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
quadVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 quadVertex;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        uniform mat4 quadVertexPositions;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {
            vec3 next = vec3(0.0, 0.0, 0.0);
            vec3 prev = vec3(0.0, 0.0, 0.0);
            if (quadVertexIndex == 0) {
                prev = quadVertexPositions[3].xyz;
                position = quadVertexPositions[0].xyz;
                next = quadVertexPositions[1].xyz;
                tangent = normalize(next - position);
            } else if (quadVertexIndex == 1) {
                prev = quadVertexPositions[0].xyz;
                position = quadVertexPositions[1].xyz;
                next = quadVertexPositions[2].xyz;
                tangent = normalize(position - prev);
            } else if (quadVertexIndex == 2) {
                prev = quadVertexPositions[1].xyz;
                position = quadVertexPositions[2].xyz;
                next = quadVertexPositions[3].xyz;
                tangent = normalize(position - next);
            } else {
                prev = quadVertexPositions[2].xyz;
                position = quadVertexPositions[3].xyz;
                next = quadVertexPositions[0].xyz;
                tangent = normalize(prev - position);
            }
            normal = normalize(cross(next - position, prev - position));
        }
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec3 getWorldDirection(vec3 modelDirection, mat4 modelMatrix) {
            return (modelMatrix * vec4(modelDirection, 0.0)).xyz;
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main() {
            vec3 position = vec3(0.0, 0.0, 0.0);
            vec3 normal = vec3(0.0, 0.0, 0.0);
            vec3 tangent = vec3(0.0, 0.0, 0.0);
            getQuadVertex(int(quadVertex.z), quadVertexPositions, position, normal, tangent);
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            gl_Position = project(viewMatrix * worldPosition, sceneProperties[0]);
            interpolatedPosition = worldPosition.xyz;
            interpolatedNormal = getWorldDirection(normal, modelMatrix);
            interpolatedUv = quadVertex.xy;
            interpolatedTangent = tangent;
        }
    |]


pointVertex :
    WebGL.Shader
        { attributes
            | position : Vec3
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , pointRadius : Float
            , viewMatrix : Mat4
            , sceneProperties : Mat4
        }
        {}
pointVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 position;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform float pointRadius;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main () {
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            gl_Position = project(viewMatrix * worldPosition, sceneProperties[0]);
            gl_PointSize = 2.0 * pointRadius + 2.0;
        }
    |]


shadowVertex :
    WebGL.Shader
        { attributes
            | position : Vec3
            , normal : Vec3
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
            , shadowLightSource : Mat4
        }
        {}
shadowVertex =
    [glsl|
        precision mediump float;
        
        attribute vec3 position;
        attribute vec3 normal;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        uniform mat4 shadowLightSource;
        
        const float kDirectionalLightSource = 1.0;
        const float kPointLightSource = 2.0;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec3 getWorldDirection(vec3 modelDirection, mat4 modelMatrix) {
            return (modelMatrix * vec4(modelDirection, 0.0)).xyz;
        }
        
        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_radius) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDirectionalLightSource) {
                return xyz_type.xyz;
            } else if (lightSourceType == kPointLightSource) {
                vec3 lightPosition = xyz_type.xyz;
                return normalize(lightPosition - surfacePosition);
            }
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLightSource, vec3 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 sceneProperties) {
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            vec3 worldNormal = getWorldDirection(normal, modelMatrix);
            vec4 xyz_type = shadowLightSource[0];
            vec4 rgb_radius = shadowLightSource[1];
            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_radius);
            vec3 offset = vec3(0.0, 0.0, 0.0);
            if (dot(directionToLight, worldNormal) <= 0.0) {
                offset = -1.0e9 * directionToLight;
            }
            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);
            return project(viewMatrix * offsetPosition, sceneProperties[0]);
        }
        
        void main () {
            gl_Position = shadowVertexPosition(
                position,
                normal,
                shadowLightSource,
                modelScale,
                modelMatrix,
                viewMatrix,
                sceneProperties
            );
        }
    |]


quadShadowVertex :
    WebGL.Shader
        { attributes
            | quadShadowVertex : Vec2
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
            , shadowLightSource : Mat4
            , quadVertexPositions : Mat4
        }
        {}
quadShadowVertex =
    [glsl|
        precision mediump float;
        
        attribute vec2 quadShadowVertex;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        uniform mat4 shadowLightSource;
        uniform mat4 quadVertexPositions;
        
        const float kDirectionalLightSource = 1.0;
        const float kPointLightSource = 2.0;
        
        void getQuadVertex(int quadVertexIndex, mat4 quadVertexPositions, out vec3 position, out vec3 normal, out vec3 tangent) {
            vec3 next = vec3(0.0, 0.0, 0.0);
            vec3 prev = vec3(0.0, 0.0, 0.0);
            if (quadVertexIndex == 0) {
                prev = quadVertexPositions[3].xyz;
                position = quadVertexPositions[0].xyz;
                next = quadVertexPositions[1].xyz;
                tangent = normalize(next - position);
            } else if (quadVertexIndex == 1) {
                prev = quadVertexPositions[0].xyz;
                position = quadVertexPositions[1].xyz;
                next = quadVertexPositions[2].xyz;
                tangent = normalize(position - prev);
            } else if (quadVertexIndex == 2) {
                prev = quadVertexPositions[1].xyz;
                position = quadVertexPositions[2].xyz;
                next = quadVertexPositions[3].xyz;
                tangent = normalize(position - next);
            } else {
                prev = quadVertexPositions[2].xyz;
                position = quadVertexPositions[3].xyz;
                next = quadVertexPositions[0].xyz;
                tangent = normalize(prev - position);
            }
            normal = normalize(cross(next - position, prev - position));
        }
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec3 getWorldDirection(vec3 modelDirection, mat4 modelMatrix) {
            return (modelMatrix * vec4(modelDirection, 0.0)).xyz;
        }
        
        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_radius) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDirectionalLightSource) {
                return xyz_type.xyz;
            } else if (lightSourceType == kPointLightSource) {
                vec3 lightPosition = xyz_type.xyz;
                return normalize(lightPosition - surfacePosition);
            }
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLightSource, vec3 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 sceneProperties) {
            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);
            vec3 worldNormal = getWorldDirection(normal, modelMatrix);
            vec4 xyz_type = shadowLightSource[0];
            vec4 rgb_radius = shadowLightSource[1];
            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_radius);
            vec3 offset = vec3(0.0, 0.0, 0.0);
            if (dot(directionToLight, worldNormal) <= 0.0) {
                offset = -1.0e9 * directionToLight;
            }
            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);
            return project(viewMatrix * offsetPosition, sceneProperties[0]);
        }
        
        void main () {
            vec3 position = vec3(0.0, 0.0, 0.0);
            vec3 normal = vec3(0.0, 0.0, 0.0);
            vec3 tangent = vec3(0.0, 0.0, 0.0);
            getQuadVertex(int(quadShadowVertex.x), quadVertexPositions, position, normal, tangent);
            normal *= quadShadowVertex.y;
            gl_Position = shadowVertexPosition(
                position,
                normal,
                shadowLightSource,
                modelScale,
                modelMatrix,
                viewMatrix,
                sceneProperties
            );
        }
    |]


sphereShadowVertex :
    WebGL.Shader
        { attributes
            | angle : Float
            , offsetScale : Float
        }
        { uniforms
            | modelScale : Vec3
            , modelMatrix : Mat4
            , viewMatrix : Mat4
            , sceneProperties : Mat4
            , shadowLightSource : Mat4
        }
        {}
sphereShadowVertex =
    [glsl|
        precision mediump float;
        
        attribute float angle;
        attribute float offsetScale;
        
        uniform vec3 modelScale;
        uniform mat4 modelMatrix;
        uniform mat4 viewMatrix;
        uniform mat4 sceneProperties;
        uniform mat4 shadowLightSource;
        
        const float kDirectionalLightSource = 1.0;
        const float kPointLightSource = 2.0;
        const float kPerspectiveProjection = 0.0;
        
        vec4 getWorldPosition(vec3 modelPosition, vec3 modelScale, mat4 modelMatrix) {
            vec4 scaledPosition = vec4(modelScale * modelPosition, 1.0);
            return modelMatrix * scaledPosition;
        }
        
        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_radius) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDirectionalLightSource) {
                return xyz_type.xyz;
            } else if (lightSourceType == kPointLightSource) {
                vec3 lightPosition = xyz_type.xyz;
                return normalize(lightPosition - surfacePosition);
            }
        }
        
        vec3 perpendicularTo(vec3 d) {
            float absX = abs(d.x);
            float absY = abs(d.y);
            float absZ = abs(d.z);
            if (absX <= absY) {
                if (absX <= absZ) {
                    float scale = 1.0 / length(d.zy);
                    return vec3(0.0, -d.z * scale, d.y * scale);
                } else {
                    float scale = 1.0 / length(d.xy);
                    return vec3(-d.y * scale, d.x * scale, 0.0);
                }
            } else {
                if (absY <= absZ) {
                    float scale = 1.0 / length(d.xz);
                    return vec3(d.z * scale, 0.0, -d.x * scale);
                } else {
                    float scale = 1.0 / length(d.xy);
                    return vec3(-d.y * scale, d.x * scale, 0.0);
                }
            }
        }
        
        vec4 project(vec4 position, vec4 projectionProperties) {
            float n = projectionProperties[0];
            float a = projectionProperties[1];
            float kc = projectionProperties[2];
            float kz = projectionProperties[3];
            return vec4(
                (kc + kz * position.z) * (position.x / a),
                (kc + kz * position.z) * position.y,
                (-position.z - 2.0 * n),
                -position.z
            );
        }
        
        void main () {
            vec4 worldCenter = getWorldPosition(vec3(0.0, 0.0, 0.0), modelScale, modelMatrix);
            vec4 xyz_type = shadowLightSource[0];
            vec4 rgb_radius = shadowLightSource[1];
            vec3 zDirection = getDirectionToLight(worldCenter.xyz, xyz_type, rgb_radius);
            vec3 xDirection = perpendicularTo(zDirection);
            vec3 yDirection = cross(zDirection, xDirection);
            float r = modelScale.x;
            float adjustedRadius = r;
            float zOffset = 0.0;
            if (xyz_type.w == kPointLightSource) {
                float distanceToLight = length(xyz_type.xyz - worldCenter.xyz);
                float rSquared = r * r;
                zOffset = rSquared / distanceToLight;
                float zSquared = zOffset * zOffset;
                adjustedRadius = sqrt(rSquared - zSquared);
            }
            vec3 worldPosition =
                worldCenter.xyz
                    + zDirection * zOffset
                    + xDirection * adjustedRadius * cos(angle)
                    + yDirection * adjustedRadius * sin(angle);
            vec3 directionToLight = getDirectionToLight(worldPosition, xyz_type, rgb_radius);
            vec3 offset = -1.0e9 * offsetScale * directionToLight;
            vec4 offsetPosition = vec4(worldPosition + offset, 1.0);
            gl_Position = project(viewMatrix * offsetPosition, sceneProperties[0]);
        }
    |]


shadowFragment : WebGL.Shader {} uniforms {}
shadowFragment =
    [glsl|
        precision mediump float;
        
        void main () {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        }
    |]


constantFragment :
    WebGL.Shader {}
        { uniforms
            | constantColor : Vec3
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
constantFragment =
    [glsl|
        precision mediump float;
        
        uniform vec3 constantColor;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        void main () {
            gl_FragColor = vec4(constantColor, 1.0);
        }
    |]


colorTextureFragment :
    WebGL.Shader {}
        { uniforms
            | colorTexture : Texture
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
colorTextureFragment =
    [glsl|
        precision mediump float;
        
        uniform sampler2D colorTexture;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        void main () {
            gl_FragColor = texture2D(colorTexture, interpolatedUv);
        }
    |]


constantPointFragment :
    WebGL.Shader {}
        { uniforms
            | constantColor : Vec3
            , pointRadius : Float
            , sceneProperties : Mat4
        }
        {}
constantPointFragment =
    [glsl|
        precision mediump float;
        
        uniform vec3 constantColor;
        uniform float pointRadius;
        uniform mat4 sceneProperties;
        
        float pointAlpha(float pointRadius, vec2 pointCoord) {
            float pointSize = 2.0 * pointRadius;
            float x = (pointSize + 2.0) * (pointCoord.s - 0.5);
            float y = (pointSize + 2.0) * (pointCoord.t - 0.5);
            float r = sqrt(x * x + y * y);
            float innerRadius = pointRadius;
            float outerRadius = pointRadius + 1.0;
            if (r > outerRadius) {
                return 0.0;
            } else if (r > innerRadius) {
                return outerRadius - r;
            } else {
                return 1.0;
            }
        }
        
        void main () {
            float alpha = pointAlpha(pointRadius, gl_PointCoord);
            gl_FragColor = vec4(constantColor, alpha);
        }
    |]


emissiveFragment :
    WebGL.Shader {}
        { uniforms
            | emissiveColor : Vec3
            , sceneProperties : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
emissiveFragment =
    [glsl|
        precision mediump float;
        
        uniform vec3 emissiveColor;
        uniform mat4 sceneProperties;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        float gammaCorrect(float u) {
            if (u <= 0.0031308) {
                return 12.92 * u;
            } else {
                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
            }
        }
        
        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {
            vec3 referenceWhite = sceneProperties[2].rgb;
            float red = gammaCorrect(linearColor.r / referenceWhite.r);
            float green = gammaCorrect(linearColor.g / referenceWhite.g);
            float blue = gammaCorrect(linearColor.b / referenceWhite.b);
            return vec4(red, green, blue, 1.0);
        }
        
        void main () {
            gl_FragColor = toSrgb(emissiveColor, sceneProperties);
        }
    |]


emissiveTextureFragment :
    WebGL.Shader {}
        { uniforms
            | colorTexture : Texture
            , backlight : Float
            , sceneProperties : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
emissiveTextureFragment =
    [glsl|
        precision mediump float;
        
        uniform sampler2D colorTexture;
        uniform float backlight;
        uniform mat4 sceneProperties;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        float inverseGamma(float u) {
            if (u <= 0.04045) {
                return clamp(u / 12.92, 0.0, 1.0);
            } else {
                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);
            }
        }
        
        vec3 fromSrgb(vec3 srgbColor) {
            return vec3(
                inverseGamma(srgbColor.r),
                inverseGamma(srgbColor.g),
                inverseGamma(srgbColor.b)
            );
        }
        
        float gammaCorrect(float u) {
            if (u <= 0.0031308) {
                return 12.92 * u;
            } else {
                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
            }
        }
        
        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {
            vec3 referenceWhite = sceneProperties[2].rgb;
            float red = gammaCorrect(linearColor.r / referenceWhite.r);
            float green = gammaCorrect(linearColor.g / referenceWhite.g);
            float blue = gammaCorrect(linearColor.b / referenceWhite.b);
            return vec4(red, green, blue, 1.0);
        }
        
        void main () {
            vec3 emissiveColor = fromSrgb(texture2D(colorTexture, interpolatedUv).rgb) * backlight;
            gl_FragColor = toSrgb(emissiveColor, sceneProperties);
        }
    |]


emissivePointFragment :
    WebGL.Shader {}
        { uniforms
            | emissiveColor : Vec3
            , pointRadius : Float
            , sceneProperties : Mat4
        }
        {}
emissivePointFragment =
    [glsl|
        precision mediump float;
        
        uniform vec3 emissiveColor;
        uniform float pointRadius;
        uniform mat4 sceneProperties;
        
        float gammaCorrect(float u) {
            if (u <= 0.0031308) {
                return 12.92 * u;
            } else {
                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
            }
        }
        
        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {
            vec3 referenceWhite = sceneProperties[2].rgb;
            float red = gammaCorrect(linearColor.r / referenceWhite.r);
            float green = gammaCorrect(linearColor.g / referenceWhite.g);
            float blue = gammaCorrect(linearColor.b / referenceWhite.b);
            return vec4(red, green, blue, 1.0);
        }
        
        void main () {
            vec3 color = toSrgb(emissiveColor, sceneProperties);
            float alpha = pointAlpha(pointRadius, gl_PointCoord);
            gl_FragColor = vec4(color, alpha);
        }
    |]


lambertianFragment :
    WebGL.Shader {}
        { uniforms
            | sceneProperties : Mat4
            , environmentalLighting : Mat4
            , lightSources12 : Mat4
            , lightSources34 : Mat4
            , lightSources56 : Mat4
            , lightSources78 : Mat4
            , materialColor : Vec3
            , viewMatrix : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
lambertianFragment =
    [glsl|
        precision mediump float;
        
        uniform mat4 sceneProperties;
        uniform mat4 environmentalLighting;
        uniform mat4 lightSources12;
        uniform mat4 lightSources34;
        uniform mat4 lightSources56;
        uniform mat4 lightSources78;
        uniform vec3 materialColor;
        uniform mat4 viewMatrix;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        const float kPerspectiveProjection = 0.0;
        const float kNoEnvironmentalLighting = 0.0;
        const float kSoftLighting = 1.0;
        const float kFastSoftLighting = 2.0;
        const float kDirectionalLightSource = 1.0;
        const float kPointLightSource = 2.0;
        const float kPi = 3.14159265359;
        const float kDisabledLightSource = 0.0;
        
        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {
            float projectionType = sceneProperties[1].w;
            if (projectionType == kPerspectiveProjection) {
                vec3 cameraPoint = sceneProperties[1].xyz;
                return normalize(cameraPoint - surfacePosition);
            } else {
                return sceneProperties[1].xyz;
            }
        }
        
        vec3 softLightingLuminance(
            vec3 aboveLuminance,
            vec3 belowLuminance,
            vec3 localUpDirection,
            vec3 localLightDirection
        ) {
            float sinElevation = dot(localLightDirection, localUpDirection);
            float t = (sinElevation + 1.0) / 2.0;
            return aboveLuminance * t + belowLuminance * (1.0 - t);
        }
        
        vec3 lambertianEnvironmentalLighting(
            vec3 normalDirection,
            vec3 materialColor,
            vec3 directionToCamera,
            mat4 viewMatrix,
            mat4 environmentalLighting
        ) {
            float environmentalLightingType = environmentalLighting[0][3];
            if (environmentalLightingType == kNoEnvironmentalLighting) {
                return vec3(0.0, 0.0, 0.0);
            } else if (environmentalLightingType == kSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 crossProduct = cross(normalDirection, directionToCamera);
                float crossMagnitude = length(crossProduct);
                vec3 xDirection = vec3(0.0, 0.0, 0.0);
                vec3 yDirection = vec3(0.0, 0.0, 0.0);
                if (crossMagnitude > 1.0e-6) {
                    yDirection = (1.0 / crossMagnitude) * crossProduct;
                    xDirection = cross(yDirection, normalDirection);
                } else {
                    vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
                    xDirection = normalize(cross(viewY, normalDirection));
                    yDirection = cross(normalDirection, xDirection);
                }
                float localUpX = dot(upDirection, xDirection);
                float localUpY = dot(upDirection, yDirection);
                float localUpZ = dot(upDirection, normalDirection);
                vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);
                
                float numSamples = 13.0;
                vec3 sum = vec3(0.0, 0.0, 0.0);
        
                vec3 localLightDirection = vec3(0.000000, 0.000000, 1.000000);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.606266, 0.000000, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, 0.606266, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.606266, 0.000000, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, -0.606266, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.873598, 0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, 0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, 0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, 0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, -0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, -0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, -0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.873598, -0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                return (2.0 * sum * materialColor) / numSamples;
            } else if (environmentalLightingType == kFastSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, normalDirection);
                return luminance * materialColor;
            } else {
                return vec3(0.0, 0.0, 0.0); 
            }
        }
        
        void getDirectionToLightAndNormalIlluminance(
            vec4 xyz_type,
            vec4 rgb_radius,
            vec3 surfacePosition,
            out vec3 directionToLight,
            out vec3 normalIlluminance
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDirectionalLightSource) {
                directionToLight = xyz_type.xyz;
                normalIlluminance = rgb_radius.rgb;
            } else if (lightSourceType == kPointLightSource) {
                vec3 lightSourcePosition = xyz_type.xyz;
                vec3 displacement = lightSourcePosition - surfacePosition;
                float distance = length(displacement);
                directionToLight = displacement / distance;
                normalIlluminance = rgb_radius.rgb / (4.0 * kPi * distance * distance);
            }
        }
        
        float positiveDotProduct(vec3 v1, vec3 v2) {
            return clamp(dot(v1, v2), 0.0, 1.0);
        }
        
        vec3 lambertianLightSource(
            vec3 surfacePosition,
            vec3 surfaceNormal,
            vec3 materialColor,
            vec4 xyz_type,
            vec4 rgb_radius
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDisabledLightSource) {
                return vec3(0.0, 0.0, 0.0);
            } 
        
            vec3 directionToLight = vec3(0.0, 0.0, 0.0);
            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);
            getDirectionToLightAndNormalIlluminance(
                xyz_type,
                rgb_radius,
                surfacePosition,
                directionToLight,
                normalIlluminance
            );
        
            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);
            return (normalIlluminance * dotNL) * (materialColor / kPi);
        }
        
        vec3 lambertianDirectLighting(
            vec3 surfacePosition,
            vec3 surfaceNormal,
            vec3 materialColor,
            mat4 lightSources12,
            mat4 lightSources34,
            mat4 lightSources56,
            mat4 lightSources78
        ) {
            vec3 litColor1 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources12[0], lightSources12[1]);
            vec3 litColor2 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources12[2], lightSources12[3]);
            vec3 litColor3 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources34[0], lightSources34[1]);
            vec3 litColor4 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources34[2], lightSources34[3]);
            vec3 litColor5 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources56[0], lightSources56[1]);
            vec3 litColor6 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources56[2], lightSources56[3]);
            vec3 litColor7 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources78[0], lightSources78[1]);
            vec3 litColor8 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources78[2], lightSources78[3]);
            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;
        }
        
        vec3 lambertianLighting(
            vec3 position,
            vec3 normalDirection,
            vec3 materialColor,
            vec3 directionToCamera,
            mat4 viewMatrix,
            mat4 environmentalLighting,
            mat4 lightSources12,
            mat4 lightSources34,
            mat4 lightSources56,
            mat4 lightSources78
        ) {
            vec3 environmentalContribution = lambertianEnvironmentalLighting(
                normalDirection,
                materialColor,
                directionToCamera,
                viewMatrix,
                environmentalLighting
            );
            vec3 directContribution = lambertianDirectLighting(
                position,
                normalDirection,
                materialColor,
                lightSources12,
                lightSources34,
                lightSources56,
                lightSources78
            );
            return environmentalContribution + directContribution;
        }
        
        float gammaCorrect(float u) {
            if (u <= 0.0031308) {
                return 12.92 * u;
            } else {
                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
            }
        }
        
        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {
            vec3 referenceWhite = sceneProperties[2].rgb;
            float red = gammaCorrect(linearColor.r / referenceWhite.r);
            float green = gammaCorrect(linearColor.g / referenceWhite.g);
            float blue = gammaCorrect(linearColor.b / referenceWhite.b);
            return vec4(red, green, blue, 1.0);
        }
        
        void main() {
            vec3 normalDirection = normalize(interpolatedNormal);
            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);
        
            vec3 linearColor = lambertianLighting(
                interpolatedPosition,
                normalDirection,
                materialColor,
                directionToCamera,
                viewMatrix,
                environmentalLighting,
                lightSources12,
                lightSources34,
                lightSources56,
                lightSources78
            );
        
            gl_FragColor = toSrgb(linearColor, sceneProperties);
        }
    |]


lambertianTextureFragment :
    WebGL.Shader {}
        { uniforms
            | sceneProperties : Mat4
            , environmentalLighting : Mat4
            , lightSources12 : Mat4
            , lightSources34 : Mat4
            , lightSources56 : Mat4
            , lightSources78 : Mat4
            , materialColorTexture : Texture
            , normalMapTexture : Texture
            , useNormalMap : Float
            , viewMatrix : Mat4
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
lambertianTextureFragment =
    [glsl|
        precision mediump float;
        
        uniform mat4 sceneProperties;
        uniform mat4 environmentalLighting;
        uniform mat4 lightSources12;
        uniform mat4 lightSources34;
        uniform mat4 lightSources56;
        uniform mat4 lightSources78;
        uniform sampler2D materialColorTexture;
        uniform sampler2D normalMapTexture;
        uniform float useNormalMap;
        uniform mat4 viewMatrix;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        const float kPerspectiveProjection = 0.0;
        const float kNoEnvironmentalLighting = 0.0;
        const float kSoftLighting = 1.0;
        const float kFastSoftLighting = 2.0;
        const float kDirectionalLightSource = 1.0;
        const float kPointLightSource = 2.0;
        const float kPi = 3.14159265359;
        const float kDisabledLightSource = 0.0;
        
        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {
            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);
            float x = 2.0 * (rgb.r - 0.5);
            float y = 2.0 * (rgb.g - 0.5);
            float z = 2.0 * (rgb.b - 0.5);
            return normalize(vec3(-x, -y, z));
        }
        
        vec3 getMappedNormal(vec3 normal, vec3 tangent, vec3 localNormal) {
            vec3 bitangent = cross(normal, tangent);
            return localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal;
        }
        
        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {
            float projectionType = sceneProperties[1].w;
            if (projectionType == kPerspectiveProjection) {
                vec3 cameraPoint = sceneProperties[1].xyz;
                return normalize(cameraPoint - surfacePosition);
            } else {
                return sceneProperties[1].xyz;
            }
        }
        
        vec3 softLightingLuminance(
            vec3 aboveLuminance,
            vec3 belowLuminance,
            vec3 localUpDirection,
            vec3 localLightDirection
        ) {
            float sinElevation = dot(localLightDirection, localUpDirection);
            float t = (sinElevation + 1.0) / 2.0;
            return aboveLuminance * t + belowLuminance * (1.0 - t);
        }
        
        vec3 lambertianEnvironmentalLighting(
            vec3 normalDirection,
            vec3 materialColor,
            vec3 directionToCamera,
            mat4 viewMatrix,
            mat4 environmentalLighting
        ) {
            float environmentalLightingType = environmentalLighting[0][3];
            if (environmentalLightingType == kNoEnvironmentalLighting) {
                return vec3(0.0, 0.0, 0.0);
            } else if (environmentalLightingType == kSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 crossProduct = cross(normalDirection, directionToCamera);
                float crossMagnitude = length(crossProduct);
                vec3 xDirection = vec3(0.0, 0.0, 0.0);
                vec3 yDirection = vec3(0.0, 0.0, 0.0);
                if (crossMagnitude > 1.0e-6) {
                    yDirection = (1.0 / crossMagnitude) * crossProduct;
                    xDirection = cross(yDirection, normalDirection);
                } else {
                    vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
                    xDirection = normalize(cross(viewY, normalDirection));
                    yDirection = cross(normalDirection, xDirection);
                }
                float localUpX = dot(upDirection, xDirection);
                float localUpY = dot(upDirection, yDirection);
                float localUpZ = dot(upDirection, normalDirection);
                vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);
                
                float numSamples = 13.0;
                vec3 sum = vec3(0.0, 0.0, 0.0);
        
                vec3 localLightDirection = vec3(0.000000, 0.000000, 1.000000);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.606266, 0.000000, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, 0.606266, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.606266, 0.000000, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, -0.606266, 0.795262);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.873598, 0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, 0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, 0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, 0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, -0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, -0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, -0.873598, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.873598, -0.361856, 0.325402);
                sum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                return (2.0 * sum * materialColor) / numSamples;
            } else if (environmentalLightingType == kFastSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, normalDirection);
                return luminance * materialColor;
            } else {
                return vec3(0.0, 0.0, 0.0); 
            }
        }
        
        void getDirectionToLightAndNormalIlluminance(
            vec4 xyz_type,
            vec4 rgb_radius,
            vec3 surfacePosition,
            out vec3 directionToLight,
            out vec3 normalIlluminance
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDirectionalLightSource) {
                directionToLight = xyz_type.xyz;
                normalIlluminance = rgb_radius.rgb;
            } else if (lightSourceType == kPointLightSource) {
                vec3 lightSourcePosition = xyz_type.xyz;
                vec3 displacement = lightSourcePosition - surfacePosition;
                float distance = length(displacement);
                directionToLight = displacement / distance;
                normalIlluminance = rgb_radius.rgb / (4.0 * kPi * distance * distance);
            }
        }
        
        float positiveDotProduct(vec3 v1, vec3 v2) {
            return clamp(dot(v1, v2), 0.0, 1.0);
        }
        
        vec3 lambertianLightSource(
            vec3 surfacePosition,
            vec3 surfaceNormal,
            vec3 materialColor,
            vec4 xyz_type,
            vec4 rgb_radius
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDisabledLightSource) {
                return vec3(0.0, 0.0, 0.0);
            } 
        
            vec3 directionToLight = vec3(0.0, 0.0, 0.0);
            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);
            getDirectionToLightAndNormalIlluminance(
                xyz_type,
                rgb_radius,
                surfacePosition,
                directionToLight,
                normalIlluminance
            );
        
            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);
            return (normalIlluminance * dotNL) * (materialColor / kPi);
        }
        
        vec3 lambertianDirectLighting(
            vec3 surfacePosition,
            vec3 surfaceNormal,
            vec3 materialColor,
            mat4 lightSources12,
            mat4 lightSources34,
            mat4 lightSources56,
            mat4 lightSources78
        ) {
            vec3 litColor1 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources12[0], lightSources12[1]);
            vec3 litColor2 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources12[2], lightSources12[3]);
            vec3 litColor3 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources34[0], lightSources34[1]);
            vec3 litColor4 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources34[2], lightSources34[3]);
            vec3 litColor5 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources56[0], lightSources56[1]);
            vec3 litColor6 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources56[2], lightSources56[3]);
            vec3 litColor7 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources78[0], lightSources78[1]);
            vec3 litColor8 = lambertianLightSource(surfacePosition, surfaceNormal, materialColor, lightSources78[2], lightSources78[3]);
            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;
        }
        
        float inverseGamma(float u) {
            if (u <= 0.04045) {
                return clamp(u / 12.92, 0.0, 1.0);
            } else {
                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);
            }
        }
        
        vec3 fromSrgb(vec3 srgbColor) {
            return vec3(
                inverseGamma(srgbColor.r),
                inverseGamma(srgbColor.g),
                inverseGamma(srgbColor.b)
            );
        }
        
        float gammaCorrect(float u) {
            if (u <= 0.0031308) {
                return 12.92 * u;
            } else {
                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
            }
        }
        
        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {
            vec3 referenceWhite = sceneProperties[2].rgb;
            float red = gammaCorrect(linearColor.r / referenceWhite.r);
            float green = gammaCorrect(linearColor.g / referenceWhite.g);
            float blue = gammaCorrect(linearColor.b / referenceWhite.b);
            return vec4(red, green, blue, 1.0);
        }
        
        void main() {
            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);
            vec3 normalDirection = getMappedNormal(normalize(interpolatedNormal), normalize(interpolatedTangent), localNormal);
            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);
            vec3 materialColor = fromSrgb(texture2D(materialColorTexture, interpolatedUv).rgb);
        
            vec3 linearColor = lambertianLighting(
                interpolatedPosition,
                normalDirection,
                materialColor,
                directionToCamera,
                viewMatrix,
                environmentalLighting,
                lightSources12,
                lightSources34,
                lightSources56,
                lightSources78
            );
        
            gl_FragColor = toSrgb(linearColor, sceneProperties);
        }
    |]


physicalFragment :
    WebGL.Shader {}
        { uniforms
            | sceneProperties : Mat4
            , environmentalLighting : Mat4
            , viewMatrix : Mat4
            , lightSources12 : Mat4
            , lightSources34 : Mat4
            , lightSources56 : Mat4
            , lightSources78 : Mat4
            , baseColor : Vec3
            , roughness : Float
            , metallic : Float
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
physicalFragment =
    [glsl|
        precision mediump float;
        
        uniform mat4 sceneProperties;
        uniform mat4 environmentalLighting;
        uniform mat4 viewMatrix;
        uniform mat4 lightSources12;
        uniform mat4 lightSources34;
        uniform mat4 lightSources56;
        uniform mat4 lightSources78;
        uniform vec3 baseColor;
        uniform float roughness;
        uniform float metallic;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        const float kPerspectiveProjection = 0.0;
        const float kNoEnvironmentalLighting = 0.0;
        const float kSoftLighting = 1.0;
        const float kFastSoftLighting = 2.0;
        const float kDirectionalLightSource = 1.0;
        const float kPointLightSource = 2.0;
        const float kPi = 3.14159265359;
        const float kMediumpFloatMax = 65504.0;
        const float kDisabledLightSource = 0.0;
        
        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {
            float projectionType = sceneProperties[1].w;
            if (projectionType == kPerspectiveProjection) {
                vec3 cameraPoint = sceneProperties[1].xyz;
                return normalize(cameraPoint - surfacePosition);
            } else {
                return sceneProperties[1].xyz;
            }
        }
        
        vec3 sampleFacetNormal(float t1, float t2, vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {
            t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;
            vec3 vNh = t1 * vT1 + t2 * vT2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * vH;
            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));
        }
        
        vec3 specularLightDirection(vec3 v, vec3 h) {
            return (2.0 * dot(v, h)) * h - v;
        }
        
        vec3 softLightingLuminance(
            vec3 aboveLuminance,
            vec3 belowLuminance,
            vec3 localUpDirection,
            vec3 localLightDirection
        ) {
            float sinElevation = dot(localLightDirection, localUpDirection);
            float t = (sinElevation + 1.0) / 2.0;
            return aboveLuminance * t + belowLuminance * (1.0 - t);
        }
        
        float positiveDotProduct(vec3 v1, vec3 v2) {
            return clamp(dot(v1, v2), 0.0, 1.0);
        }
        
        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {
            vec3 one = vec3(1.0, 1.0, 1.0);
            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);
            return specularBaseColor + (one - specularBaseColor) * scale;
        }
        
        float safeQuotient(float numerator, float denominator) {
            if (denominator == 0.0) {
                return 0.0;
            } else {
                return numerator / denominator;
            }
        }
        
        float g1(float dotNV, float alphaSquared) {
            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));
        }
        
        vec3 softLightingSpecularSample(
            vec3 aboveLuminance,
            vec3 belowLuminance,
            vec3 localUpDirection,
            vec3 localViewDirection,
            vec3 localLightDirection,
            vec3 localHalfDirection,
            float alphaSquared,
            vec3 specularBaseColor
        ) {
            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);
            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);
            float dotNL = localLightDirection.z;
            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));
        }
        
        vec3 physicalEnvironmentalLighting(
            vec3 normalDirection,
            vec3 diffuseBaseColor,
            vec3 specularBaseColor,
            float alpha,
            vec3 directionToCamera,
            mat4 viewMatrix,
            mat4 environmentalLighting
        ) {
            float environmentalLightingType = environmentalLighting[0].w;
            float alphaSquared = alpha * alpha;
        
            if (environmentalLightingType == kNoEnvironmentalLighting) {
                return vec3(0.0, 0.0, 0.0);
            }
        
            if (environmentalLightingType == kSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 crossProduct = cross(normalDirection, directionToCamera);
                float crossMagnitude = length(crossProduct);
                vec3 xDirection = vec3(0.0, 0.0, 0.0);
                vec3 yDirection = vec3(0.0, 0.0, 0.0);
                if (crossMagnitude > 1.0e-6) {
                    yDirection = (1.0 / crossMagnitude) * crossProduct;
                    xDirection = cross(yDirection, normalDirection);
                } else {
                    vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
                    xDirection = normalize(cross(viewY, normalDirection));
                    yDirection = cross(normalDirection, xDirection);
                }
                float localViewX = dot(directionToCamera, xDirection);
                float localViewZ = dot(directionToCamera, normalDirection);
                vec3 localViewDirection = vec3(localViewX, 0, localViewZ);
                float localUpX = dot(upDirection, xDirection);
                float localUpY = dot(upDirection, yDirection);
                float localUpZ = dot(upDirection, normalDirection);
                vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);
        
                vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));
                vec3 vT1 = vec3(0.0, 1.0, 0.0);
                vec3 vT2 = cross(vH, vT1);
                float s = 0.5 * (1.0 + vH.z);
                
                vec3 localHalfDirection = vec3(0.0, 0.0, 0.0);
                vec3 localLightDirection = vec3(0.0, 0.0, 0.0);
                float numSamples = 13.0;
                
                vec3 specularSum = vec3(0.0, 0.0, 0.0);
        
                localHalfDirection = sampleFacetNormal(0.000000, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.448762, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
        
                localHalfDirection = sampleFacetNormal(0.000000, 0.448762, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.448762, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.000000, -0.448762, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.748423, 0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.310007, 0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.310007, 0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.748423, 0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.748423, -0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.310007, -0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.310007, -0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.748423, -0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                vec3 diffuseSum = vec3(0.0, 0.0, 0.0);
        
                localLightDirection = vec3(0.000000, 0.000000, 1.000000);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.606266, 0.000000, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, 0.606266, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.606266, 0.000000, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, -0.606266, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.873598, 0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, 0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, 0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, 0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, -0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, -0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, -0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.873598, -0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                return (specularSum + 2.0 * diffuseSum * diffuseBaseColor) / numSamples;
            } else if (environmentalLightingType == kFastSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 crossProduct = cross(normalDirection, directionToCamera);
                float crossMagnitude = length(crossProduct);
                vec3 xDirection = vec3(0.0, 0.0, 0.0);
                vec3 yDirection = vec3(0.0, 0.0, 0.0);
                if (crossMagnitude > 1.0e-6) {
                    yDirection = (1.0 / crossMagnitude) * crossProduct;
                    xDirection = cross(yDirection, normalDirection);
                } else {
                    vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
                    xDirection = normalize(cross(viewY, normalDirection));
                    yDirection = cross(normalDirection, xDirection);
                }
                float localViewX = dot(directionToCamera, xDirection);
                float localViewZ = dot(directionToCamera, normalDirection);
                vec3 localViewDirection = vec3(localViewX, 0, localViewZ);
                float localUpX = dot(upDirection, xDirection);
                float localUpY = dot(upDirection, yDirection);
                float localUpZ = dot(upDirection, normalDirection);
                vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);

                vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));
                vec3 vT1 = vec3(0.0, 1.0, 0.0);
                vec3 vT2 = cross(vH, vT1);
                float s = 0.5 * (1.0 + vH.z);
                
                vec3 localHalfDirection = vec3(0.0, 0.0, 0.0);
                vec3 localLightDirection = vec3(0.0, 0.0, 0.0);
                
                localHalfDirection = sampleFacetNormal(0.000000, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                vec3 specular = softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localLightDirection = vec3(0.000000, 0.000000, 1.000000);
                vec3 diffuse = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                return specular + diffuse * diffuseBaseColor;
            } else {
                return vec3(0.0, 0.0, 0.0); 
            }
        }
        
        void getDirectionToLightAndNormalIlluminance(
            vec4 xyz_type,
            vec4 rgb_radius,
            vec3 surfacePosition,
            out vec3 directionToLight,
            out vec3 normalIlluminance
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDirectionalLightSource) {
                directionToLight = xyz_type.xyz;
                normalIlluminance = rgb_radius.rgb;
            } else if (lightSourceType == kPointLightSource) {
                vec3 lightSourcePosition = xyz_type.xyz;
                vec3 displacement = lightSourcePosition - surfacePosition;
                float distance = length(displacement);
                directionToLight = displacement / distance;
                normalIlluminance = rgb_radius.rgb / (4.0 * kPi * distance * distance);
            }
        }
        
        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)
        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {
            vec3 crossNH = cross(normalDirection, halfDirection);
            float a = dotNH * alpha;
            float k = alpha / (dot(crossNH, crossNH) + a * a);
            float d = k * k * (1.0 / kPi);
            return min(d, kMediumpFloatMax);
        }
        
        float specularG(float dotNL, float dotNV, float alphaSquared) {
            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);
        }
        
        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {
            vec3 halfDirection = normalize(directionToCamera + directionToLight);
            float dotVH = positiveDotProduct(directionToCamera, halfDirection);
            float dotNH = positiveDotProduct(normalDirection, halfDirection);
            float dotNHSquared = dotNH * dotNH;
        
            float d = specularD(alpha, dotNH, normalDirection, halfDirection);
            float g = specularG(dotNL, dotNV, alpha * alpha);
            vec3 f = fresnelColor(specularBaseColor, dotVH);
            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;
        }
        
        vec3 physicalLightSource(
            vec4 xyz_type,
            vec4 rgb_radius,
            vec3 surfacePosition,
            vec3 normalDirection,
            vec3 directionToCamera,
            float dotNV,
            vec3 diffuseBaseColor,
            vec3 specularBaseColor,
            float alpha
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDisabledLightSource) {
                return vec3(0.0, 0.0, 0.0);
            }
        
            vec3 directionToLight = vec3(0.0, 0.0, 0.0);
            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);
            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_radius, surfacePosition, directionToLight, normalIlluminance);
        
            float dotNL = positiveDotProduct(normalDirection, directionToLight);
            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);
            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);
        }
        
        vec3 physicalDirectLighting(
            vec3 surfacePosition,
            vec3 surfaceNormal,
            vec3 directionToCamera,
            vec3 diffuseBaseColor,
            vec3 specularBaseColor,
            float alpha,
            mat4 lightSources12,
            mat4 lightSources34,
            mat4 lightSources56,
            mat4 lightSources78
        ) {
            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);
            vec3 litColor1 = physicalLightSource(lightSources12[0], lightSources12[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor2 = physicalLightSource(lightSources12[2], lightSources12[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor3 = physicalLightSource(lightSources34[0], lightSources34[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor4 = physicalLightSource(lightSources34[2], lightSources34[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor5 = physicalLightSource(lightSources56[0], lightSources56[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor6 = physicalLightSource(lightSources56[2], lightSources56[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor7 = physicalLightSource(lightSources78[0], lightSources78[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor8 = physicalLightSource(lightSources78[2], lightSources78[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;
        }
        
        vec3 physicalLighting(
            vec3 position,
            vec3 normalDirection,
            vec3 baseColor,
            vec3 directionToCamera,
            mat4 viewMatrix,
            float roughness,
            float metallic,
            mat4 environmentalLighting,
            mat4 lightSources12,
            mat4 lightSources34,
            mat4 lightSources56,
            mat4 lightSources78
        ) {
            float alpha = roughness * roughness;
            float nonmetallic = 1.0 - metallic;
            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;
            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;
        
            vec3 environmentalContribution = physicalEnvironmentalLighting(
                normalDirection,
                diffuseBaseColor,
                specularBaseColor,
                alpha,
                directionToCamera,
                viewMatrix,
                environmentalLighting
            );
        
            vec3 directContribution = physicalDirectLighting(
                interpolatedPosition,
                normalDirection,
                directionToCamera,
                diffuseBaseColor,
                specularBaseColor,
                alpha,
                lightSources12,
                lightSources34,
                lightSources56,
                lightSources78
            );
        
            return environmentalContribution + directContribution;
        }
        
        float gammaCorrect(float u) {
            if (u <= 0.0031308) {
                return 12.92 * u;
            } else {
                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
            }
        }
        
        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {
            vec3 referenceWhite = sceneProperties[2].rgb;
            float red = gammaCorrect(linearColor.r / referenceWhite.r);
            float green = gammaCorrect(linearColor.g / referenceWhite.g);
            float blue = gammaCorrect(linearColor.b / referenceWhite.b);
            return vec4(red, green, blue, 1.0);
        }
        
        void main() {
            vec3 normalDirection = normalize(interpolatedNormal);
            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);
        
            vec3 linearColor = physicalLighting(
                interpolatedPosition,
                normalDirection,
                baseColor,
                directionToCamera,
                viewMatrix,
                roughness,
                metallic,
                environmentalLighting,
                lightSources12,
                lightSources34,
                lightSources56,
                lightSources78
            );
        
            gl_FragColor = toSrgb(linearColor, sceneProperties);
        }
    |]


physicalTexturesFragment :
    WebGL.Shader {}
        { uniforms
            | sceneProperties : Mat4
            , environmentalLighting : Mat4
            , viewMatrix : Mat4
            , lightSources12 : Mat4
            , lightSources34 : Mat4
            , lightSources56 : Mat4
            , lightSources78 : Mat4
            , baseColorTexture : Texture
            , constantBaseColor : Vec4
            , roughnessTexture : Texture
            , roughnessChannel : Vec4
            , metallicTexture : Texture
            , metallicChannel : Vec4
            , normalMapTexture : Texture
            , useNormalMap : Float
        }
        { interpolatedPosition : Vec3
        , interpolatedNormal : Vec3
        , interpolatedUv : Vec2
        , interpolatedTangent : Vec3
        }
physicalTexturesFragment =
    [glsl|
        precision mediump float;
        
        uniform mat4 sceneProperties;
        uniform mat4 environmentalLighting;
        uniform mat4 viewMatrix;
        uniform mat4 lightSources12;
        uniform mat4 lightSources34;
        uniform mat4 lightSources56;
        uniform mat4 lightSources78;
        uniform sampler2D baseColorTexture;
        uniform vec4 constantBaseColor;
        uniform sampler2D roughnessTexture;
        uniform vec4 roughnessChannel;
        uniform sampler2D metallicTexture;
        uniform vec4 metallicChannel;
        uniform sampler2D normalMapTexture;
        uniform float useNormalMap;
        
        varying vec3 interpolatedPosition;
        varying vec3 interpolatedNormal;
        varying vec2 interpolatedUv;
        varying vec3 interpolatedTangent;
        
        const float kPerspectiveProjection = 0.0;
        const float kNoEnvironmentalLighting = 0.0;
        const float kSoftLighting = 1.0;
        const float kFastSoftLighting = 2.0;
        const float kDirectionalLightSource = 1.0;
        const float kPointLightSource = 2.0;
        const float kPi = 3.14159265359;
        const float kMediumpFloatMax = 65504.0;
        const float kDisabledLightSource = 0.0;
        
        float getChannelValue(sampler2D texture, vec2 uv, vec4 channel) {
            float constantValue = channel.a;
            float useConstant = float(channel.rgb == vec3(0.0, 0.0, 0.0));
            float useTexture = 1.0 - useConstant;
            float textureValue = dot(texture2D(texture, uv).rgb, channel.rgb);
            return clamp(textureValue * useTexture + constantValue * useConstant, 0.0, 1.0);
        }
        
        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {
            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);
            float x = 2.0 * (rgb.r - 0.5);
            float y = 2.0 * (rgb.g - 0.5);
            float z = 2.0 * (rgb.b - 0.5);
            return normalize(vec3(-x, -y, z));
        }
        
        vec3 getMappedNormal(vec3 normal, vec3 tangent, vec3 localNormal) {
            vec3 bitangent = cross(normal, tangent);
            return localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal;
        }
        
        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {
            float projectionType = sceneProperties[1].w;
            if (projectionType == kPerspectiveProjection) {
                vec3 cameraPoint = sceneProperties[1].xyz;
                return normalize(cameraPoint - surfacePosition);
            } else {
                return sceneProperties[1].xyz;
            }
        }
        
        vec3 sampleFacetNormal(float t1, float t2, vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {
            t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;
            vec3 vNh = t1 * vT1 + t2 * vT2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * vH;
            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));
        }
        
        vec3 specularLightDirection(vec3 v, vec3 h) {
            return (2.0 * dot(v, h)) * h - v;
        }
        
        vec3 softLightingLuminance(
            vec3 aboveLuminance,
            vec3 belowLuminance,
            vec3 localUpDirection,
            vec3 localLightDirection
        ) {
            float sinElevation = dot(localLightDirection, localUpDirection);
            float t = (sinElevation + 1.0) / 2.0;
            return aboveLuminance * t + belowLuminance * (1.0 - t);
        }
        
        float positiveDotProduct(vec3 v1, vec3 v2) {
            return clamp(dot(v1, v2), 0.0, 1.0);
        }
        
        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {
            vec3 one = vec3(1.0, 1.0, 1.0);
            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);
            return specularBaseColor + (one - specularBaseColor) * scale;
        }
        
        float safeQuotient(float numerator, float denominator) {
            if (denominator == 0.0) {
                return 0.0;
            } else {
                return numerator / denominator;
            }
        }
        
        float g1(float dotNV, float alphaSquared) {
            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));
        }
        
        vec3 softLightingSpecularSample(
            vec3 aboveLuminance,
            vec3 belowLuminance,
            vec3 localUpDirection,
            vec3 localViewDirection,
            vec3 localLightDirection,
            vec3 localHalfDirection,
            float alphaSquared,
            vec3 specularBaseColor
        ) {
            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);
            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);
            float dotNL = localLightDirection.z;
            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));
        }
        
        vec3 physicalEnvironmentalLighting(
            vec3 normalDirection,
            vec3 diffuseBaseColor,
            vec3 specularBaseColor,
            float alpha,
            vec3 directionToCamera,
            mat4 viewMatrix,
            mat4 environmentalLighting
        ) {
            float environmentalLightingType = environmentalLighting[0].w;
            float alphaSquared = alpha * alpha;
        
            if (environmentalLightingType == kNoEnvironmentalLighting) {
                return vec3(0.0, 0.0, 0.0);
            }
        
            if (environmentalLightingType == kSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 crossProduct = cross(normalDirection, directionToCamera);
                float crossMagnitude = length(crossProduct);
                vec3 xDirection = vec3(0.0, 0.0, 0.0);
                vec3 yDirection = vec3(0.0, 0.0, 0.0);
                if (crossMagnitude > 1.0e-6) {
                    yDirection = (1.0 / crossMagnitude) * crossProduct;
                    xDirection = cross(yDirection, normalDirection);
                } else {
                    vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
                    xDirection = normalize(cross(viewY, normalDirection));
                    yDirection = cross(normalDirection, xDirection);
                }
                float localViewX = dot(directionToCamera, xDirection);
                float localViewZ = dot(directionToCamera, normalDirection);
                vec3 localViewDirection = vec3(localViewX, 0, localViewZ);
                float localUpX = dot(upDirection, xDirection);
                float localUpY = dot(upDirection, yDirection);
                float localUpZ = dot(upDirection, normalDirection);
                vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);
        
                vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));
                vec3 vT1 = vec3(0.0, 1.0, 0.0);
                vec3 vT2 = cross(vH, vT1);
                float s = 0.5 * (1.0 + vH.z);
                
                vec3 localHalfDirection = vec3(0.0, 0.0, 0.0);
                vec3 localLightDirection = vec3(0.0, 0.0, 0.0);
                float numSamples = 13.0;
                
                vec3 specularSum = vec3(0.0, 0.0, 0.0);
        
                localHalfDirection = sampleFacetNormal(0.000000, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.448762, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
        
                localHalfDirection = sampleFacetNormal(0.000000, 0.448762, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.448762, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.000000, -0.448762, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.748423, 0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.310007, 0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.310007, 0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.748423, 0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.748423, -0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(-0.310007, -0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.310007, -0.748423, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localHalfDirection = sampleFacetNormal(0.748423, -0.310007, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                specularSum += softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                vec3 diffuseSum = vec3(0.0, 0.0, 0.0);
        
                localLightDirection = vec3(0.000000, 0.000000, 1.000000);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.606266, 0.000000, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, 0.606266, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.606266, 0.000000, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.000000, -0.606266, 0.795262);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.873598, 0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, 0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, 0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, 0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.873598, -0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(-0.361856, -0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                localLightDirection = vec3(0.361856, -0.873598, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
        
                localLightDirection = vec3(0.873598, -0.361856, 0.325402);
                diffuseSum += softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                return (specularSum + 2.0 * diffuseSum * diffuseBaseColor) / numSamples;
            } else if (environmentalLightingType == kFastSoftLighting) {
                vec3 upDirection = environmentalLighting[0].xyz;
                vec3 aboveLuminance = environmentalLighting[1].rgb;
                vec3 belowLuminance = environmentalLighting[2].rgb;
                vec3 crossProduct = cross(normalDirection, directionToCamera);
                float crossMagnitude = length(crossProduct);
                vec3 xDirection = vec3(0.0, 0.0, 0.0);
                vec3 yDirection = vec3(0.0, 0.0, 0.0);
                if (crossMagnitude > 1.0e-6) {
                    yDirection = (1.0 / crossMagnitude) * crossProduct;
                    xDirection = cross(yDirection, normalDirection);
                } else {
                    vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
                    xDirection = normalize(cross(viewY, normalDirection));
                    yDirection = cross(normalDirection, xDirection);
                }
                float localViewX = dot(directionToCamera, xDirection);
                float localViewZ = dot(directionToCamera, normalDirection);
                vec3 localViewDirection = vec3(localViewX, 0, localViewZ);
                float localUpX = dot(upDirection, xDirection);
                float localUpY = dot(upDirection, yDirection);
                float localUpZ = dot(upDirection, normalDirection);
                vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);

                vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));
                vec3 vT1 = vec3(0.0, 1.0, 0.0);
                vec3 vT2 = cross(vH, vT1);
                float s = 0.5 * (1.0 + vH.z);
                
                vec3 localHalfDirection = vec3(0.0, 0.0, 0.0);
                vec3 localLightDirection = vec3(0.0, 0.0, 0.0);
                
                localHalfDirection = sampleFacetNormal(0.000000, 0.000000, vH, vT1, vT2, s, alpha);
                localLightDirection = specularLightDirection(localViewDirection, localHalfDirection);
                vec3 specular = softLightingSpecularSample(aboveLuminance, belowLuminance, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);
                
                localLightDirection = vec3(0.000000, 0.000000, 1.000000);
                vec3 diffuse = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection) * localLightDirection.z;
                
                return specular + diffuse * diffuseBaseColor;
            } else {
                return vec3(0.0, 0.0, 0.0); 
            }
        }
        
        void getDirectionToLightAndNormalIlluminance(
            vec4 xyz_type,
            vec4 rgb_radius,
            vec3 surfacePosition,
            out vec3 directionToLight,
            out vec3 normalIlluminance
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDirectionalLightSource) {
                directionToLight = xyz_type.xyz;
                normalIlluminance = rgb_radius.rgb;
            } else if (lightSourceType == kPointLightSource) {
                vec3 lightSourcePosition = xyz_type.xyz;
                vec3 displacement = lightSourcePosition - surfacePosition;
                float distance = length(displacement);
                directionToLight = displacement / distance;
                normalIlluminance = rgb_radius.rgb / (4.0 * kPi * distance * distance);
            }
        }
        
        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)
        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {
            vec3 crossNH = cross(normalDirection, halfDirection);
            float a = dotNH * alpha;
            float k = alpha / (dot(crossNH, crossNH) + a * a);
            float d = k * k * (1.0 / kPi);
            return min(d, kMediumpFloatMax);
        }
        
        float specularG(float dotNL, float dotNV, float alphaSquared) {
            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);
        }
        
        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {
            vec3 halfDirection = normalize(directionToCamera + directionToLight);
            float dotVH = positiveDotProduct(directionToCamera, halfDirection);
            float dotNH = positiveDotProduct(normalDirection, halfDirection);
            float dotNHSquared = dotNH * dotNH;
        
            float d = specularD(alpha, dotNH, normalDirection, halfDirection);
            float g = specularG(dotNL, dotNV, alpha * alpha);
            vec3 f = fresnelColor(specularBaseColor, dotVH);
            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;
        }
        
        vec3 physicalLightSource(
            vec4 xyz_type,
            vec4 rgb_radius,
            vec3 surfacePosition,
            vec3 normalDirection,
            vec3 directionToCamera,
            float dotNV,
            vec3 diffuseBaseColor,
            vec3 specularBaseColor,
            float alpha
        ) {
            float lightSourceType = xyz_type.w;
            if (lightSourceType == kDisabledLightSource) {
                return vec3(0.0, 0.0, 0.0);
            }
        
            vec3 directionToLight = vec3(0.0, 0.0, 0.0);
            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);
            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_radius, surfacePosition, directionToLight, normalIlluminance);
        
            float dotNL = positiveDotProduct(normalDirection, directionToLight);
            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);
            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);
        }
        
        vec3 physicalDirectLighting(
            vec3 surfacePosition,
            vec3 surfaceNormal,
            vec3 directionToCamera,
            vec3 diffuseBaseColor,
            vec3 specularBaseColor,
            float alpha,
            mat4 lightSources12,
            mat4 lightSources34,
            mat4 lightSources56,
            mat4 lightSources78
        ) {
            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);
            vec3 litColor1 = physicalLightSource(lightSources12[0], lightSources12[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor2 = physicalLightSource(lightSources12[2], lightSources12[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor3 = physicalLightSource(lightSources34[0], lightSources34[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor4 = physicalLightSource(lightSources34[2], lightSources34[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor5 = physicalLightSource(lightSources56[0], lightSources56[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor6 = physicalLightSource(lightSources56[2], lightSources56[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor7 = physicalLightSource(lightSources78[0], lightSources78[1], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            vec3 litColor8 = physicalLightSource(lightSources78[2], lightSources78[3], surfacePosition, surfaceNormal, directionToCamera, dotNV, diffuseBaseColor, specularBaseColor, alpha);
            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;
        }
        
        vec3 physicalLighting(
            vec3 position,
            vec3 normalDirection,
            vec3 baseColor,
            vec3 directionToCamera,
            mat4 viewMatrix,
            float roughness,
            float metallic,
            mat4 environmentalLighting,
            mat4 lightSources12,
            mat4 lightSources34,
            mat4 lightSources56,
            mat4 lightSources78
        ) {
            float alpha = roughness * roughness;
            float nonmetallic = 1.0 - metallic;
            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;
            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;
        
            vec3 environmentalContribution = physicalEnvironmentalLighting(
                normalDirection,
                diffuseBaseColor,
                specularBaseColor,
                alpha,
                directionToCamera,
                viewMatrix,
                environmentalLighting
            );
        
            vec3 directContribution = physicalDirectLighting(
                interpolatedPosition,
                normalDirection,
                directionToCamera,
                diffuseBaseColor,
                specularBaseColor,
                alpha,
                lightSources12,
                lightSources34,
                lightSources56,
                lightSources78
            );
        
            return environmentalContribution + directContribution;
        }
        
        float inverseGamma(float u) {
            if (u <= 0.04045) {
                return clamp(u / 12.92, 0.0, 1.0);
            } else {
                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);
            }
        }
        
        vec3 fromSrgb(vec3 srgbColor) {
            return vec3(
                inverseGamma(srgbColor.r),
                inverseGamma(srgbColor.g),
                inverseGamma(srgbColor.b)
            );
        }
        
        float gammaCorrect(float u) {
            if (u <= 0.0031308) {
                return 12.92 * u;
            } else {
                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
            }
        }
        
        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {
            vec3 referenceWhite = sceneProperties[2].rgb;
            float red = gammaCorrect(linearColor.r / referenceWhite.r);
            float green = gammaCorrect(linearColor.g / referenceWhite.g);
            float blue = gammaCorrect(linearColor.b / referenceWhite.b);
            return vec4(red, green, blue, 1.0);
        }
        
        void main() {
            vec3 baseColor = fromSrgb(texture2D(baseColorTexture, interpolatedUv).rgb) * (1.0 - constantBaseColor.w) + constantBaseColor.rgb * constantBaseColor.w;
            float roughness = getChannelValue(roughnessTexture, interpolatedUv, roughnessChannel);
            float metallic = getChannelValue(metallicTexture, interpolatedUv, metallicChannel);
        
            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);
            vec3 normalDirection = getMappedNormal(normalize(interpolatedNormal), normalize(interpolatedTangent), localNormal);
            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);
        
            vec3 linearColor = physicalLighting(
                interpolatedPosition,
                normalDirection,
                baseColor,
                directionToCamera,
                viewMatrix,
                roughness,
                metallic,
                environmentalLighting,
                lightSources12,
                lightSources34,
                lightSources56,
                lightSources78
            );
        
            gl_FragColor = toSrgb(linearColor, sceneProperties);
        }
    |]
